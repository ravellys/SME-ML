{"name":"Soil-moisture-estimator-with-machine-learn","tagline":"Code to estime theSoil Water Content and Actual Evapotranspiration by GaussianProcessRegressor in Caatinga area.","body":"# Estimating Soil Moisture and Actual Evapotranspiration with Machine Learning\r\n\r\nRoutine to estimate the soil water content by GaussianProcessRegressor in a Caatinga area. We trained the model with data of soil moisture, precipitation, and potential evapotranspiration provided by a flux tower installed and controlled by the INCT-ONDACBC (Instituto Nacional de Ciência e Tecnologia - Observatório Nacional da Dinâmica da Água e de Carbono no Bioma Caatinga). This tower is in a seasonal tropical dry forest (Caatinga) in the semi-arid region of Brazil (Serra Talhada - PE). For the simulation, the soil moisture, which was evaluated by TDR sensors for depths of 10, 20, 30, and 40 cm, is used as the initial condition, while precipitation and potential evapotranspiration are boundary conditions.  (http://dx.doi.org/10.17190/AMF/1562386).\r\n\r\nLocalization towers area:\r\n<img src = \"localiza%C3%A7%C3%A3o.png\">\r\n\r\n## Variables:\r\n1. dias = day\r\n2. cP = Precipitation\r\n3. ETo = potential Evapotranpiration\r\n4. ETa = actual Evapotranspiration\r\n5. tho = initial soil moisture\r\n6. x_ = features\r\n7. y_ = Target values\r\n8. TH = soil moisture estimated\r\n\r\n## Initialy, we are import the follows packages:\r\n- import numpy as np\r\n- from matplotlib import pyplot as plt\r\n- import seaborn as sns\r\n- import pandas as pd\r\n- from sklearn.gaussian_process import GaussianProcessRegressor\r\n- from sklearn.gaussian_process.kernels import RBF, WhiteKernel\r\n- from sklearn.model_selection import train_test_split\r\n- import hydroeval as he\r\n\r\n## Import mensured data\r\n```\r\ndados_medidos = pd.read_csv(\"Dados_medidos .csv\", header = 0, sep = \";\")\r\ndias = dados_medidos[\"dia\"].values[init:]\r\ncP= dados_medidos[cumulated_P].values\r\nETo = dados_medidos[\"Eto\"].values\r\n```\r\n\r\n## Plot of the correlate heatmap meansured data\r\n```\r\ndata = dados_medidos[[\"th1\",\"th2\",\"th3\",\"th4\",\"Et\",\"P\",\"Eto\"]]\r\ncorr = data.corr()\r\nax = sns.heatmap(corr, vmin=-1, vmax=1, center=0, cmap=sns.diverging_palette(20, 220, n=200),square=True)\r\nax.set_xticklabels(ax.get_xticklabels(), rotation=45,horizontalalignment='right')\r\nplt.show()\r\n```\r\n### Out:\r\n<img src = \"https://github.com/ravellys/Soil-Moisture-estimator-with-Machine-Learn/blob/master/heatmap.png\">\r\n\r\n# Estimating soil moisture\r\n## Initial soil moisture\r\n\r\n```\r\ntho = dados_medidos[[\"th1\",\"th2\",\"th3\",\"th4\"]][init:init+1].values\r\n```\r\n## Create features matrix. Note that features matrix has soil moisture data in time (i-1), and the cP data in time (i)\r\n\r\n```\r\nx_ = dados_medidos[[\"th1\",\"th2\",\"th3\",\"th4\"]][init:-1]\r\nx_[cumulated_P]= dados_medidos[[cumulated_P]][init+1:].values\r\nx_[\"Eto\"]= dados_medidos[[\"Eto\"]][init+1:].values\r\nx_[\"dia\"] = dados_medidos[[\"dia\"]][init+1:].values\r\nx_=np.atleast_2d(x_.values)\r\n```\r\n\r\n## Create the Target values with soil moisture data in time (i)\r\n\r\n```\r\ny_ = np.atleast_2d(dados_medidos[[\"th1\",\"th2\",\"th3\",\"th4\"]].values[init+1:])\r\n```\r\n\r\n## Instantiate a Gaussian Process model\r\n\r\n```\r\nkernel = 1.0 * RBF([.1,.1,.5,.5,.5,.1],(.1,5)) + WhiteKernel(noise_level=1, noise_level_bounds=(1e-5, 1e-3))\r\ngp = GaussianProcessRegressor(alpha=1e-4, kernel=kernel, n_restarts_optimizer=10, normalize_y=True,                          optimizer='fmin_l_bfgs_b')\r\n```\r\n\r\n## Separete train and test data to input in model\r\n\r\n```\r\nx_train, x_test, y_train, y_test = train_test_split(x_, y_, test_size=0.5, shuffle = False)\r\n```\r\n## Fit to data using Maximum Likelihood Estimation of the parameters\r\n\r\n```\r\nx_train2 = x_train[:,:-1]\r\ngp.fit(x_train2, y_train)\r\n```\r\n\r\n# Make the prediction \r\n\r\nThis loop the values are estimated with the initial moisture with interactive method were Th[i+1] is calculeted with TH[i]\r\n\r\n```\r\nTH = tho.tolist()\r\nfor i in range(len(y_)):\r\n    TH.append(gp.predict(np.atleast_2d(np.concatenate((TH[i],cP[i+init+1],ETo[i+init+1]), axis=None)))[0])\r\nTH = np.array(TH)\r\n```\r\n# Plot the mensured data and simulated data\r\n```\r\nfor i in range(len(TH[0])):\r\n    plt.plot(x_train[:,len(x_test[1,:])-1], y_train[:,i],'o',c = 'green',markersize=2, markerfacecolor=\"None\", label='train')\r\n    plt.plot(x_test[:,len(x_test[1,:])-1], y_test[:,i], 'o',c='red',markersize=2, markerfacecolor=\"None\", label='test')\r\n    \r\n    plt.plot(dias, TH[:,i], 'gray', label=r'$Simulado \\theta\\ %d$'%(i+1))\r\n    \r\n    NSEtest = he.nse(TH[int(x_test[:,len(x_test[1,:])-1][0]-init-1):,i],y_test[:,i])   \r\n    plt.text(260, .21, r\"$NSE_{test}: %.3f $\" %NSEtest, fontsize=12)\r\n    \r\n    NSEtrain = he.nse(TH[1:int(x_test[:,len(x_test[1,:])-1][0]-init-1),i],y_train[:,i])\r\n    plt.text(260, .23, r\"$NSE_{train}: %.3f $\" %NSEtrain, fontsize=12)\r\n\r\n    plt.xlabel('$dias$')\r\n    plt.ylabel(r'$ \\theta\\ (cm³.cm^{-3})$')\r\n    plt.ylim(.01, .25)\r\n    plt.legend(loc='upper left')\r\n    plt.show()\r\n```\r\n### Out:\r\n<img src = \"https://github.com/ravellys/Soil-Moisture-estimator-with-Machine-Learn/blob/master/th1.png\"><img src = \"https://github.com/ravellys/Soil-Moisture-estimator-with-Machine-Learn/blob/master/th2.png\">\r\n<img src = \"https://github.com/ravellys/Soil-Moisture-estimator-with-Machine-Learn/blob/master/th3.png\"><img src = \"https://github.com/ravellys/Soil-Moisture-estimator-with-Machine-Learn/blob/master/th4.png\">\r\n\r\n# Estimating Actual Evapotranspiration\r\n\r\nThe ETa is the major water flux in the hydrological cycle and it can be obtained by the Eddy Covariance method (EC). However, this is an expensive method. Therefore, this code shows a new approach to estimate the ETa by Machine Learning. We trained the model with soil moisture, rainfall and potential Evapotranspiration data (calculated by Pean-Monteith).\r\n\r\n## initial actual evapotranspiration\r\n\r\n```\r\neta_o = dados_medidos[[\"Et\"]][init:init+1].values\r\n```\r\n## create the Target values with soil moisture data in time (i) \r\n\r\n```\r\ny_eta = np.atleast_2d(dados_medidos[[\"Et\"]].values[init+1:])\r\n```\r\n\r\n## separete train and test data to input in model\r\n\r\n```\r\nx_train, x_test, y_train_eta, y_test_eta = train_test_split(x_, y_eta,test_size=0.5,shuffle = False)\r\nx_train2 = x_train[:,:-1]\r\n```\r\n## Instantiate a Gaussian Process and train model\r\n\r\n```\r\nkernel = 1.0 * RBF([.1,.1,.5,.5,.5,.1],(.1,2)) + WhiteKernel(noise_level=1, noise_level_bounds=(1e-5, 1e5))\r\ngp_eta = GaussianProcessRegressor(alpha=1e-6, kernel=kernel, n_restarts_optimizer=10, normalize_y=True,optimizer='fmin_l_bfgs_b')\r\ngp_eta.fit(x_train2, y_train_eta)\r\n```\r\n## Make the prediction\r\n\r\n```\r\nETa = eta_o.tolist()[0]\r\nfor i in range(len(y_)):\r\n    ETa.append(gp_eta.predict(np.atleast_2d((np.concatenate((TH[i],[cP[i+1]],[ETo[i+1]])))))[0,0])\r\nETa= np.array(ETa)\r\n```\r\n\r\n## Plot\r\n\r\n```\r\nplt.plot(x_train[:,len(x_test[1,:])-1], y_train_eta,'o',c = 'green',markersize=2, markerfacecolor=\"None\", label='train')\r\nplt.plot(x_test[:,len(x_test[1,:])-1], y_test_eta, 'o',c='red',markersize=2, markerfacecolor=\"None\", label='test')\r\nplt.plot(dias, ETa, 'gray', label=r'$ ETa simulado$')\r\n  \r\nNSEtest = he.nse(ETa[int(x_test[:,len(x_test[1,:])-1][0]-init-1):],y_test_eta[:,0])   \r\nplt.text(270, .5, r\"$NSE_{test}: %.3f $\" %NSEtest, fontsize=12)\r\nNSEtrain = he.nse(ETa[1:int(x_test[:,len(x_test[1,:])-1][0]-init-1)],y_train_eta[:,0])\r\nplt.text(270, .55, r\"$NSE_{train}: %.3f $\" %NSEtrain, fontsize=12)\r\n\r\nplt.xlabel('$dias$')\r\nplt.ylabel(r'$ ETa (cm.d^{-1})$')\r\nplt.ylim(.0, .6)\r\nplt.legend(loc='upper left')\r\nplt.show()\r\n```\r\n\r\n### Out:\r\n\r\n<img src = \"https://github.com/ravellys/Soil-Moisture-estimator-with-Machine-Learn/blob/master/Eta.png\">\r\n\r\n\r\n\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}